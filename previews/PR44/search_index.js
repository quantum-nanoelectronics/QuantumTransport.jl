var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"<!– Add more modules here once additional docstrings are added. –>","category":"page"},{"location":"api/#QuantumTransport.InputOutputModule.get_data-Tuple{String, String}","page":"API","title":"QuantumTransport.InputOutputModule.get_data","text":"get_data(readDir::String, filename::String)\n\nReads data from a file. The first row of the csv file should contain information about the type of plot. The second row of the file should contain the column headings. The third row onwards should contain the data.\n\nArguments\n\nreadDir::String: The directory path where the file is located.\nfilename::String: The name of the file to read.\n\nReturns\n\nThe data read from the file.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumTransport.InputOutputModule.save_data-Union{Tuple{V}, Tuple{Symbol, String, String, Vector{String}, Vector{V}}} where V<:(AbstractVector)","page":"API","title":"QuantumTransport.InputOutputModule.save_data","text":"save_data(typeofdata::Symbol, path::String, filename::String, axis_labels::Vector{String}, data::Vector{V}; kwargs...) where V <: AbstractVector\n\nSaves data to a CSV file with metadata and headers. The first line of the CSV contains serialized metadata, the second line contains column headers, and subsequent lines contain the data.\n\nArguments\n\ntypeofdata::Symbol: Specifies the type of data (e.g., :ℝ_to_ℝ, :ℝ³_to_ℝ, or \"bandstructure\").\npath::String: Directory path where the file will be saved.\nfilename::String: Name of the CSV file.\naxis_labels::Vector{String}: Labels for the data columns (e.g., axis names).\ndata::Vector{V}: Data to be saved, where each element is a vector corresponding to a column.\nkwargs...: Optional keyword arguments. Supported:\nrow_input: If true, preprocesses data as row input.\n\nMetadata Format\n\nThe metadata (first line of the CSV) is a serialized and base64-encoded Julia object containing:\n\nType of plot/data\nNumber of entries\nCodomain dimensionality\nAdditional keyword arguments\n\nData Format\n\nSecond line: Column headers (from axis_labels)\nThird line onwards: Data rows\n\nSupported typeofdata Values\n\n:ℝ_to_ℝ: 1D to 1D data (e.g., x and y columns)\n:ℝ³_to_ℝ: 3D to 1D data (e.g., x, y, z, and C columns)\n\"bandstructure\": Special handling for band structure data\n\nExample\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumTransport.WoodburyModule.block_inversion","page":"API","title":"QuantumTransport.WoodburyModule.block_inversion","text":"block_inversion(matrix, threshold=8)\n\nCompute the inverse of a block matrix using a recursive algorithm.\n\nArguments\n\nmatrix: The block matrix to be inverted.\nthreshold: The maximum size of the blocks at which the algorithm switches to directly computing the inverse using inv().\n\nReturns\n\nThe inverse of the input block matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumTransport.WoodburyModule.generate_matrix-Tuple{}","page":"API","title":"QuantumTransport.WoodburyModule.generate_matrix","text":"generate_matrix()\n\nGenerate a matrix based on some criteria.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumTransport._helperIncludeModules-Tuple{Any}","page":"API","title":"QuantumTransport._helperIncludeModules","text":"_helperIncludeModules(dir)\n\nFunction to include modules in all subdirectories of the given directory where all module files are titled Module.jl.\n\nArguments\n\ndir: The directory to include modules from.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumTransport._importAndExportModules","page":"API","title":"QuantumTransport._importAndExportModules","text":"_importAndExportModules()\n\nDynamically imports and exports modules within the QuantumTransport module.\n\nThis function iterates over the modules defined within the QuantumTransport module and dynamically imports them using the using statement. It then exports all the names defined within each module using the export statement.\n\nNo arguments are required for this function.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumTransport._includeModulesInSubdirs-Tuple{}","page":"API","title":"QuantumTransport._includeModulesInSubdirs","text":"_includeModulesInSubdirs()\n\nThis function is responsible for calling _helperIncludeModules(item), where item is each top-level subdirectory of /src. QuantumTransport module.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#geometry.jl","page":"geometry.jl","title":"geometry.jl","text":"","category":"section"},{"location":"geometry/","page":"geometry.jl","title":"geometry.jl","text":"This module provides functions for determining the material type based on position coordinates.","category":"page"},{"location":"geometry/#Tutorial","page":"geometry.jl","title":"Tutorial","text":"","category":"section"},{"location":"geometry/#Example:-Material-Determination","page":"geometry.jl","title":"Example: Material Determination","text":"","category":"section"},{"location":"geometry/","page":"geometry.jl","title":"geometry.jl","text":"To determine the material type based on position coordinates, follow these steps:","category":"page"},{"location":"geometry/","page":"geometry.jl","title":"geometry.jl","text":"Define the position coordinates using a Vector{Float64}:  julia  R = [x, y, z]\nCall the geometry function to determine the material type:  julia  material_type = geometry(R)  The geometry function returns a string indicating the material type (\"insulator\" or \"GaAs\").","category":"page"},{"location":"geometry/","page":"geometry.jl","title":"geometry.jl","text":"","category":"page"},{"location":"geometry/#Constants","page":"geometry.jl","title":"Constants","text":"","category":"section"},{"location":"geometry/","page":"geometry.jl","title":"geometry.jl","text":"geometry_params: Named tuple containing parameters for defining the geometry of the device.\nA: Matrix of unit cell lattice vectors.\nnx: Number of times to tile the cell over space in the x-direction.\nny: Number of times to tile the cell over space in the y-direction.\nnz: Number of times to tile the cell over space in the z-direction.\nprune: List of dimensions to prune.","category":"page"},{"location":"geometry/#Example-Implementation","page":"geometry.jl","title":"Example Implementation","text":"","category":"section"},{"location":"geometry/","page":"geometry.jl","title":"geometry.jl","text":"function geometry(R::Vector{Float64})\n    x = R[1]; y = R[2]; z = R[3];\n    if (x < 10*nm || x > 50*nm)\n        return \"insulator\"\n    else\n        return \"GaAs\"\n    end\nend\n\ngeometry_params = (\n    A = 2.866 * nm * I(3),   # Matrix of unit cell lattice vectors\n    nx = 50,                 # Number of times to tile the cell over space in the x-direction\n    ny = 5,                  # Number of times to tile the cell over space in the y-direction\n    nz = 1,                  # Number of times to tile the cell over space in the z-direction\n    prune = [\"x\", \"y\", \"z\"], # List of dimensions to prune\n)","category":"page"},{"location":"materials/#materials.jl","page":"materials.jl","title":"materials.jl","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"This module contains functions for computing hopping terms and other material-specific properties.","category":"page"},{"location":"materials/#Tutorial","page":"materials.jl","title":"Tutorial","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"Define the parameters for the material using a named tuple p:  julia  p = ( ... )  # Named tuple containing material parameters\nCreate an empty vector NNs to store the hopping terms:  julia  NNs = Vector{Hopping}()\nCall the metalHopping function with the parameters p, NNs, and the initial lattice site indices ia:  julia  metalHopping(p, NNs, ia)\np: Named tuple containing material parameters.\nNNs: Vector of Hopping objects representing nearest neighbor hoppings.\nia: Vector representing the indices of the initial lattice site.","category":"page"},{"location":"materials/#Functions","page":"materials.jl","title":"Functions","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"","category":"page"},{"location":"materials/#Metal-Hopping","page":"materials.jl","title":"Metal Hopping","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"This function calculates the hopping terms for metallic materials within a lattice structure and adds them to a vector of Hopping objects.","category":"page"},{"location":"materials/#Tutorial-2","page":"materials.jl","title":"Tutorial","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"To compute hopping terms for metallic materials within a lattice structure, follow these steps:","category":"page"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"Compute the orbital index iorb from the initial lattice site indices ia.\nCompute the hopping energy t.\nAdd the hopping term corresponding to the on-site energy between the initial lattice site ia and itself to the vector NNs.\nIterate over all three spatial dimensions and both positive and negative directions.\nCompute the shift vector di to determine neighboring lattice sites.\nCompute the hopping energy t and add the hopping term between the initial lattice site ia and the neighboring lattice site ib to the vector NNs.","category":"page"},{"location":"materials/#Function","page":"materials.jl","title":"Function","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"metalHopping(p::NamedTuple, NNs::Vector{Hopping}, ia::Vector{Int}): \n    Computes hopping terms for metallic materials within a lattice structure.","category":"page"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"","category":"page"},{"location":"materials/#insHopping","page":"materials.jl","title":"insHopping","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"This function calculates the hopping terms for insulating materials within a lattice structure and adds them to a vector of Hopping objects.","category":"page"},{"location":"materials/#Tutorial-3","page":"materials.jl","title":"Tutorial","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"To compute hopping terms for insulating materials within a lattice structure, follow these steps:","category":"page"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"Define the parameters for the material using a named tuple.   p: Named tuple containing material parameters.\nCreate an empty vector NNs to store the hopping terms.\nNNs = Vector{Hopping}()\nCall the insHopping function with the parameters p, NNs, and the initial lattice site indices ia.\ninsHopping(p, NNs, ia)\nIterate over neighboring lattice sites to compute hopping energies.\nCompute the orbital index iorb from the initial lattice site indices ia.\nCompute the hopping energy t using the parameters p.ϵ₁ and p.t.\nAdd the hopping term corresponding to the on-site energy between the initial lattice site ia and itself to the vector NNs.\nIterate over all three spatial dimensions and both positive and negative directions.\nCompute the shift vector di to determine neighboring lattice sites.\nCompute the hopping energy t and add the hopping term between the initial lattice site ia and the neighboring lattice site ib to the vector NNs.","category":"page"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"","category":"page"},{"location":"materials/#pushHopping","page":"materials.jl","title":"pushHopping","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"Appends a hopping term to a vector of hopping terms (NNs).","category":"page"},{"location":"materials/#Tutorial-4","page":"materials.jl","title":"Tutorial","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"Convert the initial and final lattice site indices (ia and ib) to their corresponding orbital indices (a and b) using the function xyztoi.\nConvert the initial and final lattice site indices (ia and ib) to their corresponding real-space coordinates (ra and rb) using the function xyztor.\nCalculate the displacement vector r between the initial and final sites by subtracting their real-space coordinates (rb - ra).\nCreate a new Hopping object containing the hopping information:\nOrbital indices (a and b)\nInitial and final lattice site indices (ia and ib)\nReal-space coordinates (ra and rb)\nDisplacement vector (r)\nHopping energy (t)\nFlag indicating whether the hopping term is onsite (false)\nSpin vector (set to zero vector)\nAn empty string\nAppend the newly created Hopping object to the vector NNs using the push! function.","category":"page"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"","category":"page"},{"location":"materials/#weyl3Hopping","page":"materials.jl","title":"weyl3Hopping","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"Calculates hopping terms for a 3D material with Weyl points in its band structure, considering nearest, next-nearest, and next-to-next-nearest neighbors.","category":"page"},{"location":"materials/#Tutorial-5","page":"materials.jl","title":"Tutorial","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"Define initial orbital and lattice site indices:   Extract the orbital index iorb from the fifth element of the initial lattice site indices vector ia.\nNearest neighbors:\nIterate over all three spatial dimensions ax and both positive and negative directions dir.\nCreate a displacement vector di with zero elements except for the chosen axis ax, which is set to the direction dir.\nCalculate the final lattice site indices ib by adding the displacement vector di to the initial lattice site indices ia.\nConstruct a complex hopping tensor t of size 2x2, initialized with zeros.\nBased on the chosen axis, assign values to the t tensor using the Pauli matrices (σ[1], σ[2], and σ[3]) and material parameters:\nax = 3: t = p.t * σ[3]\nax = 1: t = p.t * (-σ[3] + dir * 2im * σ[1])\nax = 2: t = p.t * (-σ[3] + dir * 2im * σ[2])\nAppend the newly created hopping term with initial and final site indices (ia and ib), hopping tensor t, and material parameters p using pushHopping! to the vector NNs.\nNext-nearest neighbors:\nIterate over all combinations of positive and negative displacements in the first two spatial dimensions dx and dy.\nCreate a displacement vector di with zeros except for the first two elements (di[1] = dx and di[2] = dy).\nCalculate the final lattice site indices ib by adding the displacement vector di to the initial lattice site indices ia.\nConstruct a complex hopping tensor t with size 2x2 and assign the value:\nt = 1.5im * p.t * (-dx * σ[1] + -dy * σ[2])\nAppend the hopping term using pushHopping! to the vector NNs.\nNext-to-next-nearest neighbors:\nIterate over the first two spatial dimensions ax.\nIterate over both positive and negative directions dir.\nCreate a displacement vector di with zeros except for the chosen axis ax, which is set to twice the direction.\nCalculate the final lattice site indices ib by adding the displacement vector di to the initial lattice site indices ia.\nConstruct a complex hopping tensor t with size 2x2 and assign the value:\nt = dir * p.t * 0.5im * σ[ax]\nAppend the hopping term using pushHopping! to the vector NNs.","category":"page"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"","category":"page"},{"location":"materials/#weyl2Hopping","page":"materials.jl","title":"weyl2Hopping","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"Calculates hopping terms for a 2D material with Weyl points in its band structure, considering nearest and next-nearest neighbors.","category":"page"},{"location":"materials/#Tutorial-6","page":"materials.jl","title":"Tutorial","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"Define initial orbital and lattice site indices:   Extract the orbital index iorb from the fifth element of the initial lattice site indices vector ia.\nNearest neighbors:\nIterate over all three spatial dimensions ax, and both positive and negative directions dir.\nCreate a displacement vector di with zero elements except for the chosen axis ax, which is set to the direction dir.\nCalculate the final lattice site indices ib by adding the displacement vector di to the initial lattice site indices ia.\nConstruct a complex hopping tensor t of size 2x2, initialized with zeros.\nBased on the chosen axis, assign values to the t tensor using the Pauli matrices (σ[1], σ[2], and σ[3]) and material parameters:\nax = 1: t = p.t * (σ[1] - σ[3])\nax = 2: t = -p.t * (σ[1] + σ[3])\nax = 3: t = p.t * σ[3]\nAppend the newly created hopping term with initial and final site indices, hopping tensor, and material parameters using pushHopping! to the vector NNs.\nNext-nearest neighbors:\nIterate over all combinations of positive and negative displacements in the first two spatial dimensions dx and dy.\nCreate a displacement vector di with zeros except for the first two elements (di[1] = dx and di[2] = dy).\nCalculate the final lattice site indices ib by adding the displacement vector di to the initial lattice site indices ia.\nConstruct a complex hopping tensor t with size 2x2 and assign the value:\nt = -dx * dy * 0.5 * p.t * σ[2]\nAppend the hopping term using pushHopping! to the vector NNs.","category":"page"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"","category":"page"},{"location":"materials/#chern2DHopping","page":"materials.jl","title":"chern2DHopping","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"Calculates hopping terms for a 2D material with Chern points, considering on-site energy, nearest-neighbor coupling mediated by spin-orbit interaction, and normal hopping between nearest neighbor orbitals.","category":"page"},{"location":"materials/#Tutorial-7","page":"materials.jl","title":"Tutorial","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"On-site term:\nExtract the orbital index iorb from ia[5].\nCalculate the hopping energy t for the on-site term:\nt = nextsite(iorb) * (2 * p.m2 + p.γ) * I(2)\nnextsite(iorb): Returns the orbital index of the nearest neighbor based on the current orbital iorb.\nI(2): Identity matrix of size 2x2.\nAppend a new Hopping object to NNs with:\nInitial and final site indices: ia (both initial and final sites are the same for on-site term).\nHopping energy: t.\nMaterial parameters: p.\nNearest-neighbor term:\nIterate over all three spatial dimensions ax and both positive and negative directions dir.\nCreate a displacement vector di with zeros except for the chosen axis ax, which is set to the direction dir.\nSet the fifth element of di to nextsite(iorb), indicating the nearest neighbor orbital index shift.\nCalculate the final lattice site indices ib by adding the displacement vector di to the initial lattice site indices ia.\nConstruct the hopping energy t for the nearest-neighbor term:\nt = (im/2) * dir * p.t * σ[ax]\nim: Imaginary unit.\ndir: Direction (+1 or -1).\np.t: Material parameter (hopping strength).\nσ[ax]: Pauli matrix corresponding to the chosen axis (ax).\nAppend a new Hopping object to NNs with:\nInitial and final site indices.\nHopping energy: t.\nMaterial parameters: p.\nNormal hopping term:\nModify the fifth element of ib back to the original orbital index iorb (hopping between orbitals on the same site).\nCalculate the hopping energy t for the normal hopping term:\nt = - (1/2) * nextsite(iorb) * p.m2 * I(2)\nThis term represents the direct hopping between nearest neighbor orbitals and contributes to the overall band structure.\nAppend a new Hopping object to NNs with:\nInitial and final site indices.\nHopping energy: t.\nMaterial parameters: p.","category":"page"},{"location":"runs/#runs.jl","page":"runs.jl","title":"runs.jl","text":"","category":"section"},{"location":"runs/","page":"runs.jl","title":"runs.jl","text":"This file contains parameters for configuring different types of simulations.","category":"page"},{"location":"runs/#Tutorial","page":"runs.jl","title":"Tutorial","text":"","category":"section"},{"location":"runs/#Example:-Running-Simulations","page":"runs.jl","title":"Example: Running Simulations","text":"","category":"section"},{"location":"runs/","page":"runs.jl","title":"runs.jl","text":"To run simulations with different configurations, follow these steps:","category":"page"},{"location":"runs/","page":"runs.jl","title":"runs.jl","text":"Define the directory path where simulation data will be stored:  julia  path = \"./\"\nConfigure parameters for simulations focusing on the electronic properties of a single unit cell:  julia  unitcell = (      bands = true,      bands_project = [σ[1], γ⁵],      poisson = false,      DOS = false  )\nbands: Boolean indicating whether to compute electronic band structure.\nbands_project: List of projection operators for computing bands.\npoisson: Boolean indicating whether to include Poisson solver.\nDOS: Boolean indicating whether to compute density of states.\nConfigure parameters for simulations focusing on voltage-dependent transport properties:  julia  transport = (      ΔV = 0.05,      μ = 0.1 * eV,      T = 300,      η = 1E-4 * eV,      savedensities = true,      density_project = [I(2), [σ[1], σ[2], σ[3]]],      Gʳinv_method = \"CBR\",      D_dephasing = 0.1 * eV,      D_spin = 0.01 * eV,      D_momentum = 0.5 * eV,      kspace = false  )\nΔV: Voltage bias.\nμ: Chemical potential.\nT: Temperature.\nη: Broadening parameter for densities.\nsavedensities: Boolean indicating whether to save density matrices.\ndensity_project: List of projection operators for density matrices.\nGʳinv_method: Method for computing Green's function inverse.\nD_dephasing: Dephasing parameter.\nD_spin: Spin relaxation parameter.\nD_momentum: Momentum relaxation parameter.\nkspace: Boolean indicating whether to use k-space.\nConfigure parameters for simulations using multiple unit cells:  julia  supercell = (      bands = true,      bands_project = [σ[1], σ[2]],      poisson = true,      μ = 0.1 * eV,      T = 300,      η = 1E-4 * eV,      savedensities = true,      density_project = [I(2), [σ[1], σ[2], σ[3]]],      Gʳinv_method = \"CBR\",      D_dephasing = 0.1 * eV,      D_spin = 0.01 * eV,      D_momentum = 0.5 * eV  )  (Same parameters as unitcell and transport)\nCreate a named tuple runparams containing the configured parameters:  julia  runparams = (path = path, unitcell = unitcell, transport = transport, supercell = supercell)\nUse the run_simulation function with the runparams tuple to execute the simulation:  julia  run_simulation(runparams)","category":"page"},{"location":"runs/","page":"runs.jl","title":"runs.jl","text":"","category":"page"},{"location":"runs/#Constants","page":"runs.jl","title":"Constants","text":"","category":"section"},{"location":"runs/","page":"runs.jl","title":"runs.jl","text":"path: Path to the directory where simulation data will be stored.","category":"page"},{"location":"runs/","page":"runs.jl","title":"runs.jl","text":"","category":"page"},{"location":"#QuantumTransport.jl","page":"Home","title":"QuantumTransport.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantumTransport.jl is a Julia package designed for simulating quantum transport phenomena in nanoscale electronic devices.","category":"page"},{"location":"#Status","page":"Home","title":"Status","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: CI Status)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package supports Julia 1.9.3 and above on Linux, MacOS, and Windows.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install QuantumTransport.jl, open the Julia REPL, type ] to enter package mode, and run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add QuantumTransport","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively, using the Pkg API:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\n\njulia> Pkg.add(\"QuantumTransport\")","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After installing QuantumTransport, you can start using the package with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using QuantumTransport\n\n# Your simulation code goes here","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the examples/ directory for real-world simulations and usage patterns.","category":"page"},{"location":"#Contributing-and-Support","page":"Home","title":"Contributing and Support","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We welcome contributions! Please open a new pull request from a feature branch. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you have a bug report, feature request, or general question, please open an issue.","category":"page"},{"location":"#Running-Tests","page":"Home","title":"Running Tests","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you're developing the package locally, you can run the test suite from the Julia Pkg REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> activate /your/path/to/the/cloned/QuantumTransport.jl/.\n\npkg> instantiate\n\npkg> test","category":"page"}]
}
