var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#QuantumTransport.InputOutputModule.get_data","page":"API","title":"QuantumTransport.InputOutputModule.get_data","text":"get_data(readDir::String, filename::String)\n\nReads data from a file. The first row of the csv file should contain information about the type of plot. The second row of the file should contain the column headings. The third row onwards should contain the data.\n\nArguments\n\nreadDir::String: The directory path where the file is located.\nfilename::String: The name of the file to read.\n\nReturns\n\nThe data read from the file.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumTransport.WoodburyModule.block_inversion","page":"API","title":"QuantumTransport.WoodburyModule.block_inversion","text":"block_inversion(matrix, threshold=8)\n\nCompute the inverse of a block matrix using a recursive algorithm.\n\nArguments\n\nmatrix: The block matrix to be inverted.\nthreshold: The maximum size of the blocks at which the algorithm switches to directly computing the inverse using inv().\n\nReturns\n\nThe inverse of the input block matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumTransport.WoodburyModule.generate_matrix","page":"API","title":"QuantumTransport.WoodburyModule.generate_matrix","text":"generate_matrix()\n\nGenerate a matrix based on some criteria.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#geometry.jl","page":"geometry.jl","title":"geometry.jl","text":"","category":"section"},{"location":"geometry/","page":"geometry.jl","title":"geometry.jl","text":"This documentation describes the input file used to define device geometry, simulation parameters, and material properties in a quantum transport simulation framework.","category":"page"},{"location":"geometry/","page":"geometry.jl","title":"geometry.jl","text":"","category":"page"},{"location":"geometry/#Input-File:-geometry.jl","page":"geometry.jl","title":"Input File: geometry.jl","text":"","category":"section"},{"location":"geometry/","page":"geometry.jl","title":"geometry.jl","text":"Provides functions to determine material type based on position coordinates.","category":"page"},{"location":"geometry/#Tutorial:-Material-Determination","page":"geometry.jl","title":"Tutorial: Material Determination","text":"","category":"section"},{"location":"geometry/","page":"geometry.jl","title":"geometry.jl","text":"To determine the material type at a given point:","category":"page"},{"location":"geometry/","page":"geometry.jl","title":"geometry.jl","text":"Define position coordinates:\nR = [x, y, z]  # Vector{Float64}\nCall the geometry function:\nmaterial_type = geometry(R)\nThe result is a String: either \"insulator\" or \"GaAs\".","category":"page"},{"location":"geometry/#Constants","page":"geometry.jl","title":"Constants","text":"","category":"section"},{"location":"geometry/","page":"geometry.jl","title":"geometry.jl","text":"geometry_params: Named tuple of device geometry settings:\nA: Unit cell lattice vector matrix\nnx, ny, nz: Number of tiled unit cells in each dimension\nprune: Dimensions to prune","category":"page"},{"location":"geometry/#Example-Code","page":"geometry.jl","title":"Example Code","text":"","category":"section"},{"location":"geometry/","page":"geometry.jl","title":"geometry.jl","text":"module geometry\n\nusing QuantumTransport\nexport geometry, geometry_params\n\nfunction geometry(R::Vector{Float64})\n    x, y, z = R\n    if (x < 10 * nm || x > 50 * nm)\n        return \"insulator\"\n    else\n        return \"GaAs\"\n    end\nend\n\ngeometry_params = (\n    A = 2.866 * nm * I(3),\n    nx = 50,\n    ny = 5,\n    nz = 1,\n    prune = [\"x\", \"y\", \"z\"],\n)\n\nend  # module","category":"page"},{"location":"materials/#materials.jl","page":"materials.jl","title":"materials.jl","text":"","category":"section"},{"location":"materials/#Materials","page":"materials.jl","title":"Materials","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"Provides functionality to compute material-specific hopping terms.","category":"page"},{"location":"materials/#Example-Usage","page":"materials.jl","title":"Example Usage","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"Define material parameters:\np = ( ... )  # Named tuple\nCreate a container for hopping terms:\nNNs = Vector{Hopping}()\nCall the material-specific hopping function:\nmetalHopping(p, NNs, ia)","category":"page"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"p: Named tuple of material parameters\nNNs: Vector of Hopping objects\nia: Indices of the initial lattice site","category":"page"},{"location":"materials/#Metal-Hopping","page":"materials.jl","title":"Metal Hopping","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"This function calculates the hopping terms for metallic materials within a lattice structure and adds them to a vector of Hopping objects.","category":"page"},{"location":"materials/#Tutorial","page":"materials.jl","title":"Tutorial","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"To compute hopping terms for metallic materials within a lattice structure, follow these steps:","category":"page"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"Iterate over neighboring lattice sites to compute hopping energies.\nCompute the orbital index iorb from the initial lattice site indices ia.\nCompute the hopping energy t.\nAdd the hopping term corresponding to the on-site energy between the initial lattice site ia and itself to the vector NNs.\nIterate over all three spatial dimensions and both positive and negative directions.\nCompute the shift vector di to determine neighboring lattice sites.\nCompute the hopping energy t and add the hopping term between the initial lattice site ia and the neighboring lattice site ib to the vector NNs.","category":"page"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"Function","category":"page"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"metalHopping(p::NamedTuple, NNs::Vector{Hopping}, ia::Vector{Int})","category":"page"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"","category":"page"},{"location":"materials/#insHopping","page":"materials.jl","title":"insHopping","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"This function calculates the hopping terms for insulating materials within a lattice structure and adds them to a vector of Hopping objects.","category":"page"},{"location":"materials/#Tutorial-2","page":"materials.jl","title":"Tutorial","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"Define the parameters for the material using a named tuple p.\nCreate an empty vector NNs to store the hopping terms.","category":"page"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"NNs = Vector{Hopping}()","category":"page"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"Call the insHopping function with the parameters p, NNs, and the initial lattice site indices ia.","category":"page"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"insHopping(p, NNs, ia)","category":"page"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"Iterate over neighboring lattice sites to compute hopping energies.\nCompute the orbital index iorb from the initial lattice site indices ia.\nCompute the hopping energy t using the parameters p.ϵ₁ and p.t.\nAdd the hopping term corresponding to the on-site energy between the initial lattice site ia and itself to the vector NNs.\nIterate over all three spatial dimensions and both positive and negative directions.\nCompute the shift vector di to determine neighboring lattice sites.\nCompute the hopping energy t and add the hopping term between the initial lattice site ia and the neighboring lattice site ib to the vector NNs.","category":"page"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"","category":"page"},{"location":"materials/#pushHopping","page":"materials.jl","title":"pushHopping","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"Appends a hopping term to a vector of hopping terms (NNs).","category":"page"},{"location":"materials/#Tutorial-3","page":"materials.jl","title":"Tutorial","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"Convert the initial and final lattice site indices (ia and ib) to their corresponding orbital indices (a and b) using the function xyztoi.\nConvert the initial and final lattice site indices (ia and ib) to their corresponding real-space coordinates (ra and rb) using the function xyztor.\nCalculate the displacement vector r between the initial and final sites by subtracting their real-space coordinates (rb - ra).\nCreate a new Hopping object containing the hopping information.\nAppend the newly created Hopping object to the vector NNs using the push! function.","category":"page"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"","category":"page"},{"location":"materials/#weyl3Hopping","page":"materials.jl","title":"weyl3Hopping","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"Calculates hopping terms for a 3D material with Weyl points in its band structure, considering nearest, next-nearest, and next-to-next-nearest neighbors.","category":"page"},{"location":"materials/#Tutorial-4","page":"materials.jl","title":"Tutorial","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"Define initial orbital and lattice site indices.\nNearest neighbors: Iterate and compute hopping tensors using Pauli matrices based on axis and direction.\nNext-nearest neighbors: Use combinations of displacements in 2D to define hopping.\nNext-to-next-nearest neighbors: Use doubled displacements and compute hopping energy using Pauli matrices.","category":"page"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"","category":"page"},{"location":"materials/#weyl2Hopping","page":"materials.jl","title":"weyl2Hopping","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"Calculates hopping terms for a 2D material with Weyl points in its band structure, considering nearest and next-nearest neighbors.","category":"page"},{"location":"materials/#Tutorial-5","page":"materials.jl","title":"Tutorial","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"Define initial orbital and lattice site indices.\nNearest neighbors: Iterate and compute hopping tensors based on axis and direction.\nNext-nearest neighbors: Use combinations of displacements to define hopping energy using Pauli matrices.","category":"page"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"","category":"page"},{"location":"materials/#chern2DHopping","page":"materials.jl","title":"chern2DHopping","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"Calculates hopping terms for a 2D material with Chern points, considering on-site energy, nearest-neighbor coupling mediated by spin-orbit interaction, and normal hopping between nearest neighbor orbitals.","category":"page"},{"location":"materials/#Tutorial-6","page":"materials.jl","title":"Tutorial","text":"","category":"section"},{"location":"materials/","page":"materials.jl","title":"materials.jl","text":"On-site term: Use nextsite(iorb) and material parameters to compute t.\nNearest-neighbor term: Use displacement vectors and compute t with spin-orbit interaction using Pauli matrices.\nNormal hopping term: Restore original orbital index and compute direct hopping energy using identity matrix.","category":"page"},{"location":"runs/#runs.jl","page":"runs.jl","title":"runs.jl","text":"","category":"section"},{"location":"runs/","page":"runs.jl","title":"runs.jl","text":"Defines parameters for different types of simulations.","category":"page"},{"location":"runs/#Tutorial:-Running-Simulations","page":"runs.jl","title":"Tutorial: Running Simulations","text":"","category":"section"},{"location":"runs/","page":"runs.jl","title":"runs.jl","text":"Set the output path:\npath = \"./\"\nDefine simulation modes:","category":"page"},{"location":"runs/#Unit-Cell-Simulation","page":"runs.jl","title":"➤ Unit Cell Simulation","text":"","category":"section"},{"location":"runs/","page":"runs.jl","title":"runs.jl","text":"unitcell = (\n    bands = true,\n    bands_project = [σ[1], γ⁵],\n    poisson = false,\n    DOS = false\n)","category":"page"},{"location":"runs/#Transport-Simulation","page":"runs.jl","title":"➤ Transport Simulation","text":"","category":"section"},{"location":"runs/","page":"runs.jl","title":"runs.jl","text":"transport = (\n    ΔV = 0.05,\n    μ = 0.1 * eV,\n    T = 300,\n    η = 1e-4 * eV,\n    savedensities = true,\n    density_project = [I(2), [σ[1], σ[2], σ[3]]],\n    Gʳinv_method = \"CBR\",\n    D_dephasing = 0.1 * eV,\n    D_spin = 0.01 * eV,\n    D_momentum = 0.5 * eV,\n    kspace = false\n)","category":"page"},{"location":"runs/#Supercell-Simulation","page":"runs.jl","title":"➤ Supercell Simulation","text":"","category":"section"},{"location":"runs/","page":"runs.jl","title":"runs.jl","text":"supercell = (\n    bands = true,\n    bands_project = [σ[1], σ[2]],\n    poisson = true,\n    μ = 0.1 * eV,\n    T = 300,\n    η = 1e-4 * eV,\n    savedensities = true,\n    density_project = [I(2), [σ[1], σ[2], σ[3]]],\n    Gʳinv_method = \"CBR\",\n    D_dephasing = 0.1 * eV,\n    D_spin = 0.01 * eV,\n    D_momentum = 0.5 * eV\n)","category":"page"},{"location":"runs/","page":"runs.jl","title":"runs.jl","text":"Create a named tuple with the simulation setup:","category":"page"},{"location":"runs/","page":"runs.jl","title":"runs.jl","text":"runparams = (\n    path = path,\n    unitcell = unitcell,\n    transport = transport,\n    supercell = supercell\n)","category":"page"},{"location":"runs/","page":"runs.jl","title":"runs.jl","text":"Run the simulation:","category":"page"},{"location":"runs/","page":"runs.jl","title":"runs.jl","text":"run_simulation(runparams)","category":"page"},{"location":"#QuantumTransport.jl","page":"Home","title":"QuantumTransport.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for QuantumTransport.jl.","category":"page"},{"location":"#QuantumTransport._helperIncludeModules-Tuple{Any}","page":"Home","title":"QuantumTransport._helperIncludeModules","text":"_helperIncludeModules(dir)\n\nFunction to include modules in all subdirectories of the given directory where all module files are titled Module.jl.\n\nArguments\n\ndir: The directory to include modules from.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumTransport._importAndExportModules","page":"Home","title":"QuantumTransport._importAndExportModules","text":"_importAndExportModules()\n\nDynamically imports and exports modules within the QuantumTransport module.\n\nThis function iterates over the modules defined within the QuantumTransport module and dynamically imports them using the using statement. It then exports all the names defined within each module using the export statement.\n\nNo arguments are required for this function.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumTransport._includeModulesInSubdirs-Tuple{}","page":"Home","title":"QuantumTransport._includeModulesInSubdirs","text":"_includeModulesInSubdirs()\n\nThis function is responsible for calling _helperIncludeModules(item), where item is each top-level subdirectory of /src. QuantumTransport module.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumTransport.WoodburyModule.block_inversion","page":"Home","title":"QuantumTransport.WoodburyModule.block_inversion","text":"block_inversion(matrix, threshold=8)\n\nCompute the inverse of a block matrix using a recursive algorithm.\n\nArguments\n\nmatrix: The block matrix to be inverted.\nthreshold: The maximum size of the blocks at which the algorithm switches to directly computing the inverse using inv().\n\nReturns\n\nThe inverse of the input block matrix.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumTransport.WoodburyModule.generate_matrix-Tuple{}","page":"Home","title":"QuantumTransport.WoodburyModule.generate_matrix","text":"generate_matrix()\n\nGenerate a matrix based on some criteria.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumTransport.InputOutputModule.get_data-Tuple{String, String}","page":"Home","title":"QuantumTransport.InputOutputModule.get_data","text":"get_data(readDir::String, filename::String)\n\nReads data from a file. The first row of the csv file should contain information about the type of plot. The second row of the file should contain the column headings. The third row onwards should contain the data.\n\nArguments\n\nreadDir::String: The directory path where the file is located.\nfilename::String: The name of the file to read.\n\nReturns\n\nThe data read from the file.\n\n\n\n\n\n","category":"method"}]
}
